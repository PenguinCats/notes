# 缓存

缓存目的：第一次请求时将一些耗时操作的结果暂存，以后遇到相同的请求，直接返回暂存的数据。

具体可参见 7days-golang 分布式缓存章节。这里只讲一讲缓存面临的一些问题。

1. 缓存面临的问题

   1. 缓存穿透：

      描述：查询一个**不存在**的 key，**每次**请求都会穿透到 DB，如果瞬间流量过大，导致负载过大。

      解决方案：

      1. 接口校验：在正常业务流程中可能会存在少量访问不存在 key 的情况，但是一般不会出现大量的情况，所以这种场景最大的可能性是遭受了非法攻击。可以在最外层先做一层校验：用户鉴权、**数据合法性校验**等，例如商品查询中，商品的ID是正整数，则可以直接对非正整数直接过滤等等。

      2. 缓存空值：当访问缓存和DB都没有查询到值时，可以将空值写进缓存，但是设置较短的过期时间，该时间需要根据产品业务特性来设置

      3. 布隆过滤器：使用布隆过滤器存储所有可能访问的 key，不存在的 key 直接被过滤，存在的 key 则再进一步查询缓存和数据库

         > 一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。
         >
         > - 优点：空间效率和查询时间都远远超过一般的算法。
         > - 缺点：有一定的误识别率，删除困难。
         >
         > 布隆过滤器本质上是一个 n 位的二进制数组，用0和1表示。对于某一个 `id1` ，进行三次哈希，并确定其在二进制数组中的位置，并将其置位。
         >
         > ![img](v2-4aa0b83327b9157c11460827fb56ce23_b.jpg)

   2. 缓存击穿：

      描述：**某个 key** 在过期的那一刻，这个 key 的多个请求击穿到 DB，造成 DB 瞬时负载过大

      解决方案：

      1. single flight，在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。
      2. 热点数据不过期。直接将缓存设置为不过期，然后由定时任务去异步加载数据，更新缓存。

   3. 缓存雪崩：

      描述：**多个 key** 在同一时间全部失效，大量请求打到 DB（不同 key 的多个请求和同一 key 的多个请求 都存在），引起雪崩。通常是因为缓存服务器宕机或是所有 key 设定的相同的过期时间

      解决方案：

      1. 过期时间打散。给缓存的过期时间时加上一个随机值时间，使得每个 key 的过期时间分布开来，不会集中在同一时刻失效。
      2. 辅助使用缓存击穿的处理办法：single flight 和 热点数据不过期



缓存中间件：Redis
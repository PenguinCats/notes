# 面试题没想出来的题目

1. weak_ptr 的使用场景

   weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，因为它不具有普通指针的行为，**没有重载 operator * 和 ->**，它的最大作用在于协助 shared_ptr 工作，像旁观者那样观测资源的使用情况。

   + use_count()：可以观测资源的引用计数
   + expired()：的功能等价于 use_count()==0, 但更快
     + 如果返回 false，可能是过失的。并发的情况下，可能你刚获取完，这个 shared_ptr 就没有人引用了。（上面的 use_count 函数也存在这个问题）
     + true 结果肯定是线程安全的。
   + lock()：从被观测的 shared_ptr 获得一个可用的 shared_ptr 对象， 从而操作资源。但当 expired()==true 的时候，lock() 函数将返回一个存储空指针的shared_ptr。

   使用场景：

   + 解决循环引用问题。两个对象中有 shared_ptr 互相指向，比如父类和子类的对象中，或者同一个类的对象也可能相互指向（二叉树的父节点和子节点）。
   + 当你想使用一个对象但不想管理他：比如说你有一个定时器，其关联了一个 Struct。每隔一段时间，你就要把这个 Struct 中的字段全部打印一遍。这个 Struct 可能由其他结构管理，可能在一些情况下，Struct 被删除。那么你的定时器，在 lock() 的时候就会拿到一个空指针，结束。如果你用了一个 shared_ptr，那么这个 Struct 就不会执行析构，浪费了空间。注意，管理 Struct 的结构可能根本不知道这个定时器的存在，所以你不能指望删除这个 Struct 的时候也删除这个定时器。

2. auto 怎么做的

   编译的时候编译器可以推断出是什么类型。比如 auto p = a + b，a 和 b 都是 int，那编译器能够根据 a+b 的返回类型推断出 auto 是什么。deltype 也是。

   需要注意的的，auto 会忽略顶层 const，保留底层 const。

   > 顶层 const：代表指针本身是常量，声明时必须初始化，之后**它存储的值（可能是地址；也可能是一个普通的值，比如 `const int  = 5`）就不能再改变**。
   >
   > 底层 const：**指向常量的指针**：代表不能改变其**指向内容**的指针。
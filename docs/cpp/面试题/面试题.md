# 面试题没想出来的题目

1. weak_ptr 的使用场景

   weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，因为它不具有普通指针的行为，**没有重载 operator * 和 ->**，它的最大作用在于协助 shared_ptr 工作，像旁观者那样观测资源的使用情况。

   + use_count()：可以观测资源的引用计数
   + expired()：的功能等价于 use_count()==0, 但更快
     + 如果返回 false，可能是过失的。并发的情况下，可能你刚获取完，这个 shared_ptr 就没有人引用了。（上面的 use_count 函数也存在这个问题）
     + true 结果肯定是线程安全的。
   + lock()：从被观测的 shared_ptr 获得一个可用的 shared_ptr 对象， 从而操作资源。但当 expired()==true 的时候，lock() 函数将返回一个存储空指针的shared_ptr。

   使用场景：

   + 解决循环引用问题。两个对象中有 shared_ptr 互相指向，比如父类和子类的对象中，或者同一个类的对象也可能相互指向（二叉树的父节点和子节点）。
   + 当你想使用一个对象但不想管理他：比如说你有一个定时器，其关联了一个 Struct。每隔一段时间，你就要把这个 Struct 中的字段全部打印一遍。这个 Struct 可能由其他结构管理，可能在一些情况下，Struct 被删除。那么你的定时器，在 lock() 的时候就会拿到一个空指针，结束。如果你用了一个 shared_ptr，那么这个 Struct 就不会执行析构，浪费了空间。注意，管理 Struct 的结构可能根本不知道这个定时器的存在，所以你不能指望删除这个 Struct 的时候也删除这个定时器。

2. auto 怎么做的

   编译的时候编译器可以推断出是什么类型。比如 auto p = a + b，a 和 b 都是 int，那编译器能够根据 a+b 的返回类型推断出 auto 是什么。deltype 也是。

   需要注意的的，auto 会忽略顶层 const，保留底层 const。

   > 顶层 const：代表指针本身是常量，声明时必须初始化，之后**它存储的值（可能是地址；也可能是一个普通的值，比如 `const int  = 5`）就不能再改变**。
   >
   > 底层 const：**指向常量的指针**：代表不能改变其**指向内容**的指针。

3. setrlimit 有啥？

   | FLAG              | 内容                                                         |
   | ----------------- | ------------------------------------------------------------ |
   | RLIMIT_AS         | 进程的最大虚内存空间，字节为单位。                           |
   | RLIMIT_CORE       | 内核转存（dump）文件的最大长度。<br>我们可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。 |
   | RLIMIT_CPU        | 最大允许的CPU使用时间，秒为单位。<br>当进程达到软限制，内核将给其发送 SIGXCPU 信号，这一信号的默认行为是终止进程的执行。然而，可以捕捉信号，处理句柄可将控制返回给主程序。如果进程继续耗费 CPU 时间，核心会以每秒一次的频率给其发送 SIGXCPU 信号，直到达到硬限制，那时将给进程发送 SIGKILL 信号终止其执行。 |
   | RLIMIT_DATA       | 进程数据段的最大值。                                         |
   | RLIMIT_FSIZE      | 进程可建立的文件的最大长度。如果进程试图超出这一限制时，核心会给其发送SIGXFSZ信号，默认情况下将终止进程的执行。 |
   | RLIMIT_LOCKS      | 进程可建立的锁和租赁的最大值。                               |
   | RLIMIT_MEMLOCK    | 进程可锁定在内存中的最大数据量，**字节为单位**。             |
   | RLIMIT_MSGQUEUE   | 进程可为POSIX消息队列分配的最大字节数。                      |
   | RLIMIT_NICE       | 进程可通过 setpriority() 或 nice() 调用设置的最大完美值。    |
   | RLIMIT_NOFILE     | 指定比进程可打开的**最大文件描述词**上限（开区间），超出此值，将会产生EMFILE错误。 |
   | RLIMIT_NPROC      | 用户可拥有的最大进程数。（或者Linux上的线程）                |
   | RLIMIT_RTPRIO     | 进程可通过sched_setscheduler 和 sched_setparam设置的最大实时优先级。 |
   | RLIMIT_SIGPENDING | 用户可拥有的最大挂起信号数。（或更准确地说，在 Linux 上是线程）。 |
   | RLIMIT_STACK      | 最大的进程堆栈，以字节为单位。                               |

   限制分为硬限制和软限制：

   + 进程可以将某资源的软限制值更改为小于或等于其硬限制值；
   + 任何一个进程可以降低某资源的硬限制值，但必须大于等于对应资源的软限制值，且这种“降低”对于非root用户是不可逆的；
   + 只有root用户进程可以提高硬限制值；

   这允许管理员（或有权限的用户）将硬限制设置为他们希望允许的最大使用量。然后，其他用户和进程可以使用软限制，将其资源使用自我限制到更低的水平，如果他们愿意的话。

4. 安全隔离

   > https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt
   >
   > https://www.linuxhowtos.org/manpages/3/seccomp_rule_add_exact.htm

   secure computing mode。通过添加规则，比如触发 fork 时就杀掉程序

   ```c++
   scmp_filter_ctx ctx;
   ctx = seccomp_init(SCMP_ACT_ALLOW); 
   seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(fork), 0); 
   seccomp_load(ctx);
   ```

   

   
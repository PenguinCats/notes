# 面试题没想出来的题目

1. weak_ptr 的使用场景
   
   weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，因为它不具有普通指针的行为，**没有重载 operator * 和 ->**，它的最大作用在于协助 shared_ptr 工作，像旁观者那样观测资源的使用情况。
   
   + use_count()：可以观测资源的引用计数
   + expired()：的功能等价于 use_count()==0, 但更快
     + 如果返回 false，可能是过失的。并发的情况下，可能你刚获取完，这个 shared_ptr 就没有人引用了。（上面的 use_count 函数也存在这个问题）
     + true 结果肯定是线程安全的。
   + lock()：从被观测的 shared_ptr 获得一个可用的 shared_ptr 对象， 从而操作资源。但当 expired()==true 的时候，lock() 函数将返回一个存储空指针的shared_ptr。
   
   使用场景：
   
   + 解决循环引用问题。两个对象中有 shared_ptr 互相指向，比如父类和子类的对象中，或者同一个类的对象也可能相互指向（二叉树的父节点和子节点）。
   + 当你想使用一个对象但不想管理他：比如说你有一个定时器，其关联了一个 Struct。每隔一段时间，你就要把这个 Struct 中的字段全部打印一遍。这个 Struct 可能由其他结构管理，可能在一些情况下，Struct 被删除。那么你的定时器，在 lock() 的时候就会拿到一个空指针，结束。如果你用了一个 shared_ptr，那么这个 Struct 就不会执行析构，浪费了空间。注意，管理 Struct 的结构可能根本不知道这个定时器的存在，所以你不能指望删除这个 Struct 的时候也删除这个定时器。

2. auto 怎么做的
   
   > 好像也不是下面我说的这些，可以看看这个。 
   > C++11中的auto和decltype的原理? - 知乎用户y3FgF3的回答 - 知乎
   > https://www.zhihu.com/question/294048058/answer/489015726
   
   编译的时候编译器可以推断出是什么类型。比如 auto p = a + b，a 和 b 都是 int，那编译器能够根据 a+b 的返回类型推断出 auto 是什么。deltype 也是。
   
   需要注意的的，auto 会忽略顶层 const，保留底层 const。
   
   > 顶层 const：代表指针本身是常量，声明时必须初始化，之后**它存储的值（可能是地址；也可能是一个普通的值，比如 `const int  = 5`）就不能再改变**。
   > 
   > 底层 const：**指向常量的指针**：代表不能改变其**指向内容**的指针。

3. setrlimit 有啥？
   
   | FLAG              | 内容                                                                                                                                                                        |
   | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | RLIMIT_AS         | 进程的最大虚内存空间，字节为单位。                                                                                                                                                         |
   | RLIMIT_CORE       | 内核转存（dump）文件的最大长度。<br>我们可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。                                        |
   | RLIMIT_CPU        | 最大允许的CPU使用时间，秒为单位。<br>当进程达到软限制，内核将给其发送 SIGXCPU 信号，这一信号的默认行为是终止进程的执行。然而，可以捕捉信号，处理句柄可将控制返回给主程序。如果进程继续耗费 CPU 时间，核心会以每秒一次的频率给其发送 SIGXCPU 信号，直到达到硬限制，那时将给进程发送 SIGKILL 信号终止其执行。 |
   | RLIMIT_DATA       | 进程数据段的最大值。                                                                                                                                                                |
   | RLIMIT_FSIZE      | 进程可建立的文件的最大长度。如果进程试图超出这一限制时，核心会给其发送SIGXFSZ信号，默认情况下将终止进程的执行。                                                                                                               |
   | RLIMIT_LOCKS      | 进程可建立的锁和租赁的最大值。                                                                                                                                                           |
   | RLIMIT_MEMLOCK    | 进程可锁定在内存中的最大数据量，**字节为单位**。                                                                                                                                                |
   | RLIMIT_MSGQUEUE   | 进程可为POSIX消息队列分配的最大字节数。                                                                                                                                                    |
   | RLIMIT_NICE       | 进程可通过 setpriority() 或 nice() 调用设置的最大完美值。                                                                                                                                  |
   | RLIMIT_NOFILE     | 指定比进程可打开的**最大文件描述词**上限（开区间），超出此值，将会产生EMFILE错误。                                                                                                                            |
   | RLIMIT_NPROC      | 用户可拥有的最大进程数。（或者Linux上的线程）                                                                                                                                                 |
   | RLIMIT_RTPRIO     | 进程可通过sched_setscheduler 和 sched_setparam设置的最大实时优先级。                                                                                                                       |
   | RLIMIT_SIGPENDING | 用户可拥有的最大挂起信号数。（或更准确地说，在 Linux 上是线程）。                                                                                                                                      |
   | RLIMIT_STACK      | 最大的进程堆栈，以字节为单位。                                                                                                                                                           |
   
   限制分为硬限制和软限制：
   
   + 进程可以将某资源的软限制值更改为小于或等于其硬限制值；
   + 任何一个进程可以降低某资源的硬限制值，但必须大于等于对应资源的软限制值，且这种“降低”对于非root用户是不可逆的；
   + 只有root用户进程可以提高硬限制值；
   
   这允许管理员（或有权限的用户）将硬限制设置为他们希望允许的最大使用量。然后，其他用户和进程可以使用软限制，将其资源使用自我限制到更低的水平，如果他们愿意的话。

4. 安全隔离
   
   > https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt
   > 
   > https://www.linuxhowtos.org/manpages/3/seccomp_rule_add_exact.htm
   
   secure computing mode。通过添加规则，比如触发 fork 时就杀掉程序
   
   ```c++
   scmp_filter_ctx ctx;
   ctx = seccomp_init(SCMP_ACT_ALLOW); 
   seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(fork), 0); 
   seccomp_load(ctx);
   ```

5. 工程化：makefile & cmake【以后有空再看】
   
   1. make& makefile: 
      
      make可以看成是一个智能的**批处理**工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用**makefile文件**中用户指定的命令来进行编译和链接的
      
      makefile命令中包含了调用 gcc（也可以是别的编译器）去编译某个源文件的命令
   
   2. cmake 可以更加简单的生成 makefile 文件给上面那个 make 用。cmake 可以**跨平台**生成对应平台能用的 makefile，我们就不用再自己去修改了。
      
      它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成 makefile。

6. 引用和指针的区别
   
   指针是一个变量，存储的数据类型是数据的地址。
   
   在不启用编译器优化的情况下，主流编译器都会选择将 C++ 中的引用解释为 const 指针。（所以其实是会占内存的啊！）
   
   > 其实不是说“把引用解释成指针”吧。
   > 在机器码层面，也不存在指针，只存在地址（指针其实还隐含了类型信息）。变量这个概念也是不存在的，只有“无格式数据”，被带格式的指令操作而已。所以你看到引用和指针的效果一样，是因为在机器码层面，没有多余的信息去表明他们的区别了。而在语言层面，引用的确可以理解为 const 指针。
   > 
   > 另外，引用也绝不是编译器简单做了一个地址替换。引用的实现中把地址复制一遍也是很正常的，编译器也的确没法在编译期完全分析出引用的具体指向。考虑如下代码：`int a=0,b=1; int& c = flag ? a : b;`，引用只不过因为 const 所以不能被重置，但具体指向什么，是可以运行期决定的。
   > 
   > 引用的一个优点是它一定不为空，因此相对于指针，它不用检查它所指对象是否为空，这增加了效率
   
   引用的一些好处:
   
   + 省去了指针判空的消耗
   + 指针降维 （通过引用让代码看上去易懂一些）
   + 更好的支持链式调用  `a.funca().funcb().funcc().funcd()`

7. 进程突然崩了怎么排查呢？
   
   在 linux 下开发时，如果程序突然崩溃了，也没有任何日志。这时可以查看 core 文件。从 core 文件中分析原因，通过 gdb 看出程序挂在哪里，分析前后的变量，找出问题的原因。
   
   当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做 Core Dump。我们可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。
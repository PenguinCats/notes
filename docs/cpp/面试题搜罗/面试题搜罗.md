# 面试题搜罗

## 关于内存

### volatile

- volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- 当变量可能被某些编译器未知的因素（操作系统、硬件、其它线程等）更改，就使用 volatile 告诉编译器不应对这样的对象进行优化。

### sizeof

- sizeof 对数组，得到整个数组所占空间大小。
- sizeof 对指针，得到指针本身所占空间大小。



## 关于进程线程的操作、锁

## 关于类

### this

+ `this` 指针是一个隐含于每一个**非静态成员函数**中的特殊指针。它指向调用该成员函数的那个对象。
+ 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。
+ 按照 object 是否为 const，可以看作是传入了一个 `const ClassName *` or `const ClassName* const`
+ `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。【一般是编译器推断出来直接可用的值，而不会占用对象的内部空间。】

### C++ 中 struct、class、union

> 除了默认权限，他们没什么分别

struct 默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

默认的继承访问权限类似。struct 是 public 的，class 是 private 的。

union 以后再说

> C 实现 C++ 类（以后再说）
>
> C 实现 C++ 的面向对象特性（封装、继承、多态）
>
> - 封装：使用函数指针把属性与方法封装到结构体中
> - 继承：结构体嵌套
> - 多态：父类与子类方法的函数指针不同
>
> > [Can you write object-oriented code in C? [closed\]](https://stackoverflow.com/a/351745)

### explicit（显式）关键字

+ explicit 修饰构造函数时，可以防止隐式转换和**复制初始化**
+ explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外

```cpp
struct B
{
    explicit B(int) {}
    explicit operator bool() const { return true; }
};

void doB(B b) {}

int main()
{
    B b1(1);        // OK：直接初始化
    B b2 = 1;        // 错误：被 explicit 修饰构造函数的对象不可以复制初始化
    B b3{ 1 };        // OK：直接列表初始化
    B b4 = { 1 };        // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
    B b5 = (B)1;        // OK：允许 static_cast 的显式转换
    doB(1);            // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
    if (b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
    bool b6(b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
    bool b7 = b1;        // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
    bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化

    return 0;
}
```

### friend 友元类和友元函数

- 能访问私有成员，破坏了封装性
- 友元关系不可传递、且是单向的

常见于运算符重载

```c++
class Vector{
	private:
	...
	public:
		...
		Vector & operator*(const Vector v) const;
		friend Vector & operator*(double n, const Vector v);
		Vector & operator*(double n, const Vector v) const;
    	// 即使把 ostream 类作为 Vector 的友元类也没用，因为我没法改动 ostream 类的结构体，为其增加成员函数，因此只能搞一个非成员函数。
    	friend ostream & operator<<( ostream & os,const Vector & v);
}
```

### 枚举类

在C++11新标准中推出了一种新的枚举定义办法叫做枚举类，也称作强类型枚举。（默认的底层类型是 int 类型）

```c++
enum class 枚举类型名: 底层类型 {枚举值列表};
enum class Type { General, Light, Medium, Heavy};//所有枚举常量都是int类型
enum class Type: char { General, Light, Medium, Heavy};//所有枚举常量都是字符类型
enum class Category { General=1, Pistol, MachineGun, Cannon};//后面的枚举常量值依次增加
```

好处：

+ 枚举类的强作用域就是把这个**作用域限制在枚举类里面**，就可以**避免在不同枚举类型之间的枚举值重名的问题**。
+ 转换限制，枚举类对象不可以与整型隐式地互相转换。（C 语言在程序中是可以直接使用枚举值的）
+ 可以指定底层类型

## 关于 STL 和底层实现

## 一些不知道怎么分类的东西

### const

修饰变量、指针（const pointer & pointer to const）、引用（refer to cosnt）、成员函数

### static

+ 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区（已初始的数据段 or BSS 段）
+ 修饰普通函数**，表明函数的作用范围，**仅在定义该函数的文件内才能使用**。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static
+ 修饰全局变量，同上
+ 修饰成员变量和成员函数

### inline

- 相当于把内联函数里面的内容写在调用内联函数处，就像做了一个替换一样，不用执行进入函数的步骤，直接执行函数体；
- 比宏多了类型检查，真正具有函数特性
- 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数（是一个请求而并不保证实现）
- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

#### 编译器对 inline 函数的处理步骤

1. 将 inline 函数体复制到 inline 函数调用点处；
2. 为所用 inline 函数中的局部变量分配内存空间；
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
4. 如果 inline 函数有多个返回点，使用 GOTO 跳到最后。

#### 带来的问题

1. 代码膨胀。内联是以代码膨胀（复制）为代价，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。

#### 虚函数可以 inline 吗

内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不会去内联。

内联是在**建议编译器内联**，而**虚函数的多态性在运行期**，编译器无法知道**运行期**调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。

### assert

断言，**是宏，而非函数**。如果它的条件返回错误，则终止程序执行。可以通过定义 `NDEBUG` 来关闭 assert。

```c++
#ifdef  NDEBUG  
  
    #define assert(_Expression)     ((void)0)  
  
#else  
  
    void _wassert(const wchar_t * _Message, const wchar_t *_File, unsigned _Line);  
    #define assert(_Expression) (void)( (!!(_Expression)) || (_wassert(_CRT_WIDE(#_Expression), _CRT_WIDE(__FILE__), __LINE__), 0) )  
  
#endif    
```

### extern "C"

`C++` 支持函数重载，而过程式语言 `C` 则不支持。所以，函数被 `C++` 编译后在符号库中的名字与 `C` 语言的有所不同。例如，假设某个函数的原型为：

```c++
void foo( int x, int y );
```

该函数被 `C` 编译器编译后在符号库中的名字为 `_foo` ，而 `C++` 编译器则会产生像 `_foo_int_int` 之类的名字。`extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，可以**避免 C++ 因符号修饰导致代码不能和 C 语言库中的符号进行链接**的问题。

### using 与 域

1. using 用于导入命名空间。导入入命名空间的一个成员或整个命名空间。

```c++
using namespace_name::name;
using namespacee namespace_name;
```

> **在派生类中引用基类的成员其实也是这个道理**
>
> 例如 class B(A){...};
>
> 在 B 的某个中可以调用 A 的某个函数或变量（即使因为重名被隐藏。例如 `A::funtion_a()`）

> 尽量少引入整个命名空间，这样会污染当前命名空间，导致冲突。局部名称将覆盖命名空间名称，且编译器无警告。

2. 用于声明别名

   ```c++
   using T = int 等价于 typedef int T
   ```

3. 把基类的构造函数拿来用，生成一个基于父类的构造函数

   ```c++
   class A {
   public:
       A(){...};
   };
   class B: A {
       using A::A;
   };
   
   // 等价于自动生成了
   B(parms) : A(args) { }
   ```

> 全局作用域符（`::name`）：用于访问全局命名空间的 name，通常在被隐藏又需要访问的时候使用

### decltype

当你需要某个表达式的返回值类型而又不想实际执行它时用decltype。**编译器进行类型推导**

```c++
int a=8, b=3;
decltype(a + b) d; //编译期类型推导
auto c=a + b; //运行时需要实际执行a+b，哪怕编译时就能推导出类型
```

## C++  11

### 复杂的引用

> https://zhuanlan.zhihu.com/p/404741698
>
> https://zhuanlan.zhihu.com/p/335994370
>
> https://zhuanlan.zhihu.com/p/54050093

1. 左值和右值

   **简单来说**（不严谨的来说）：

   + 左值位于等号左侧，看成是一个可以获取地址的量，他的生命周期不会马上结束（比如局部变量要一直到函数末尾）

   + 右值没法取地址，位于等号右侧（比如常量或者临时值）。【暂时理解为，右值用完这一次就没用了】

   ```c++
   // 下面 a 是左值，5 是右值
   int a = 5;
   ```

   ```c++
   struct A {
       A(int a = 0) {
           a_ = a;
       }
    
       int a_;
   };
    // 下面 a 是左值，A() 这个临时变量是右值
   A a = A();
   ```

2. 左值引用

   在 `C++11` 之前就已经有了左值引用，简称为引用

   ```c++
   int x = 20;
   int& rx = x;   // 定义引用时必须初始化
   ```

   但是引用也分为 const 引用与 non-const 引用，**对于 non-const 左值引用，只能用 non-const 左值左值来初始化**：

   ```c++
   int x = 20;
   int& rx1 = x;     // non-const引用可以被non-const左值初始化
   
   const int y = 10;
   int& rx2 = y;     // 非法：non-const引用不能被const左值初始化
   int& rx3 = 10;    // 非法：non-const引用不能被右值初始化
   ```

   但是 const 没有这个限制，其可以用 非 const 左值、const 左值、**右值** 来初始化。【尤其注意哦，const 左值引用可以接收右值】

3. 右值引用

   可以认为，**右值引用的目的是为了延长马上就没用的右值的生命周期**，是一种**重用**。因此：

   + 右值引用**一旦初始化成功了，这个变量就是左值了**【因为我要重用了】
   + 右值引用一定**不能被左值所初始化**，因为左值的生命周期与其作用域有关，你没有必要去延长。

   ```c++
   int x = 20;            // 左值
   
   int&& rrx1 = x;        // 非法：右值引用无法被左值初始化
   const int&& rrx2 = x;  // 非法：右值引用无法被左值初始化
   
   int&& rx = x * 2;      // x*2的结果是一个右值，rx 延长其生命周期，rx 现在是一个左值了
   int y = rx + 2;        // 既然 rx 是左值，因此你当然可以重用它：42
   ```

综上所述，我们简单回顾一下，用下面的函数说明

```c++
// 接收左值
void fun(int& lref)
{
    cout << "l-value reference\n";
}
// 接收右值
void fun(int&& rref)
{
    cout << "r-value reference\n";
}

int main()
{
    int x = 10;
    fun(x);   // output: l-value reference
    fun(10);  // output: r-value reference
}

// 如果你定义成这样，即可以接收左值，也可以接收右值【因为 const 左值引用可以绑定右值】
void fun(const int& clref)
{
    cout << "l-value const reference\n";
}
```

4. 移动语义

   移动语义的关键目的是，将马上就没用的变量的控制权（或其资源等），直接转移给新的对象，避免申请新的内存空间和执行深拷贝，节省时间。我们来看看不用移动构造的动态数组会遇到什么：

   ```c++
   template <typename T>
   class DynamicArray {
   public:
       explicit DynamicArray(int size) :
           m_size{ size }, m_array{ new T[size] } {
           cout << "Constructor: dynamic array is created!\n";
       }
   
       virtual ~DynamicArray() {
           delete[] m_array;
           cout << "Destructor: dynamic array is destroyed!\n";
       }
   
       // 复制构造函数
       DynamicArray(const DynamicArray& rhs) :
           m_size{ rhs.m_size } {
           m_array = new T[m_size];
           for (int i = 0; i < m_size; ++i)
               m_array[i] = rhs.m_array[i];
           cout << "Copy constructor: dynamic array is created!\n";
       }
   
       // 复制赋值操作符
       DynamicArray& operator=(const DynamicArray& rhs) {
           cout << "Copy assignment operator is called\n";
           if (this == &rhs)
               return *this;
   
           delete[] m_array;
   
           m_size = rhs.m_size;
           m_array = new T[m_size];
           for (int i = 0; i < m_size; ++i)
               m_array[i] = rhs.m_array[i];
   
           return *this;
       }
   
       // 索引运算符
       T& operator[](int index) {
           // 不进行边界检查
           return m_array[index];
       }
   
       const T& operator[](int index) const {
           return m_array[index];
       }
   
       int size() const { return m_size; }
   private:
       T* m_array;
       int m_size;
   };
   
   // 生产 int 动态数组的工厂函数
   DynamicArray<int> arrayFactor(int size)
   {
       DynamicArray<int> arr{ size };
       return arr;
   }
   
   int main()
   {
       {
           DynamicArray<int> arr = arrayFactor(10);
       }
       return 0;
   }
   
   // 输出为
   Constructor: dynamic array is created!
   Copy constructor: dynamic array is created!
   Destructor: dynamic array is destroyed!
   Destructor: dynamic array is destroyed!
   ```

   其大致的过程为：

   1. arrayFactor 内部创建了一个动态数组 arr
   2. 将这个 arr 返回，但是它是内部变量，所以返回给一个用来返回的临时变量（回顾一下 OS，函数调用前就会给返回值分配空间）。这个临时变量使用复制构造函数初始化
   3. 在 main 函数中，再将其以复制赋值的形式，传递给 A。（不过这样好蠢，不如直接用内部的 arr 初始化外部的 arr。编译器也这么想，所以就优化掉了这一步）
   4. 先是内部的 arr 被析构，然后外部的 arr 被析构

   我们可以看到，尽管编译器做了优化，但是还是导致对象被创建了两次，函数内部创建的动态数组仅仅是一个中间对象，用完后就被析构了。那能不能**直接将内部的 arr 转移给外部的 arr** 呢？这样资源就可以重用，实际上只用申请一份内存。

   > 注意！const 形参可以绑定非 const 实参。但是非 const 形参不能绑定 const 实参。也就是说，这里的移动构造函数接受的是一个右值引用，而不是 const 右值引用。

   此时，我们需要移动构造函数。简而言之，当传入右值用于构造的时候，我们执行移动构造函数内的操作，通常是直接把指针指过去，然后把右值引用的空间收回（**注意噢，传入右值之后，用右值引用绑定，然后这个右值引用就是左值了，所以可以把其指针清空**）。

   ```c++
   template <typename T>
   class DynamicArray
   {
   public:
       // ...其它省略
   
       // 移动构造函数
       DynamicArray(DynamicArray&& rhs) :
           m_size{ rhs.m_size }, m_array{rhs.m_array}
       {
           rhs.m_size = 0;
           rhs.m_array = nullptr;
           cout << "Move constructor: dynamic array is moved!\n";
       }
   
       // 移动赋值操作符
       DynamicArray& operator=(DynamicArray&& rhs)
       {
           cout << "Move assignment operator is called\n";
           if (this == &rhs)
               return *this;
           delete[] m_array;
           m_size = rhs.m_size;
           m_array = rhs.m_array;
           rhs.m_size = 0;
           rhs.m_array = nullptr;
   
           return *this;
       }
   };
   ```

   这样的话执行相同代码，我们就能看到：

   ```c++\
   Constructor: dynamic array is created!
   Move constructor: dynamic array is moved!
   Destructor: dynamic array is destroyed!
   Destructor: dynamic array is destroyed!
   ```

   析构函数被调用两次，这是因为尽管内部进行了内存转移，但是临时对象依然存在，只不过第一次析构函数析构的是一个`nullptr`，这不会对程序有影响。

   **在 `C++11` 中，`STL` 的容器都实现了移动构造函数与移动赋值运算符，这将大大优化 `STL` 容器。**

   > 如果你试图移动一个简单变量 int char 之类的，没什么意义。同样，这些基本类型又不会有一个移动构造函数（他们搞不好都不是 class 吧）去清空原来的值，所以你试图移动一个 int 原来的值肯定不会变啊。

5. std::move

   之前吧，右值都是运行时候判定的。但是有时候你**自己用完一个左值变量之后，你知道它之后就再也没有用了**。但是**移动构造函数只支持传入右值**啊，咋办？那就**强行把左值当成右值来用**！

   c++ 11 中，`std::move` 就是干这个事情的。具体实现不管了，涉及到万能引用，引用折叠之类的。**就当它做了一个 static_cast 强制类型转换。**原来是右值的，还是右值；原来是左值的，强行看作是右值。

   > **`std::move` 只是一个类型转换，没有真的 move 什么东西。如果要 move 的话，要靠接收右值引用的函数去做。**

   > 不过有一个注意点。`std::move` 会保留原来的 const 属性。也就是说，如果传入了左值，`std::move` 的输出是 const 右值引用类型。
   >
   > 这样的话你在匹配构造函数的时候，是匹配不上移动构造函数的（接收非 const 参数）。但是因为 const 左值引用可以绑定右值，所以你没有调用移动构造函数，而是调用了复制构造函数。那就没用上移动的好处了。
   >
   > ```cpp
   > class string
   > {
   >     // ...
   >     string(const string& rhs);   // 复制构造函数
   >     string(string&& rhs);    // 移动构造函数
   > }
   > ```

6. 万能引用、std::forward 与完美转发

   首先，我们看一下这个情况：在模板中，万能引用 `T&&` 允许你既传入左值也传入右值，写法是下面这样：

   ```c++
   template<typename T>
   void wrapper(T&& param);               // here, “&&”does not mean rvalue reference
   ```

   根据引用折叠规则【具体不管了】，如果你传入一个左值，T&& 就当作是一个左值，如果你传入一个右值，T&& 就当作是一个右值。

   你在 foo 里面进行了一点简单的处理，然后想根据左值还是右值，再用另一个函数 foo 处理它。于是你想这样写：

   ```c++
   // 目标函数
   void foo(const string& str);   // 接收左值
   void foo(string&& str);        // 接收右值
   
   template <typename T>
   void wrapper(T&& param)
   {
       ... // 一些公共操作
       foo(param);
   }
   ```

   但是出问题了啊啊啊，之前说过，**右值引用在初始化之后，就变成左值了啊**。因此即使你传入的 param 原来是一个右值，因为你延长了它的生存期，他现在是一个左值啊。所以它只会去匹配那个接收左值的 foo 函数，而不是接收右值的 foo 函数。这违背你的本意了。这需要用到所谓的完美转发：

   > **完美转发**就是创建一个函数，该函数可以接收任意类型的参数，然后将这些参数**按原来的类型转发给目标函数**，完美转发的实现要依靠`std::forward`。

   所以，我们在传递给 foo 之前，要利用 `std::forward` 对 param 做一下转换。如果原来 param 是右值，那出来的就是右值；如果原来是左值，那出来的就是左值。

   ```c++
   template <typename T>
   void wrapper(T&& param)
   {
       foo(std::forward<T>(param));  // 完美转发
   }
   ```

   那 `std::forward` 是怎么做到的呢？把 T 拿进来用：

   ```c++
   template<typename T> 
   T&& forward(typename remove_reference<T>::type& param) 
   {
       return static_cast<T&&>(param);
   }
   ```

   还是根据引用折叠规则，如果你传入一个左值，T&& 就当作是一个左值，如果你传入一个右值，T&& 就当作是一个右值。

   关于完美转发的实际使用场景，我找到了这样的说法：

   > 在 STL 中，随处可见这种问题。比如C++11引入的`emplace_back`，它接受左值也接受右值作为参数，接着，它转调用了空间配置器的 construct 函数，而 construct 又转调用了 `placement new`，`placement new` 根据参数是左值还是右值，决定调用拷贝构造函数还是移动构造函数。
   >
   >  https://zhuanlan.zhihu.com/p/369203981
   >
   > 
   >
   > 个人理解：之前我有疑惑，直接调用 foo() 不就行了，干嘛费劲呢。如果你要执行公共操作  func_a(param)，先调用它就是了。但是**作为模板作者，这是一个包装**。你不能指望用户先执行 fun_a(param)，再调用 foo(param)。你必须帮它包裹起来，让用户**只**调用 wrapper(param)，内部你来操作。

   

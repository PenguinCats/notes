# 特性与机制
## 栈逃逸机制
GO 函数中允许返回局部变量的地址。Go编译器使用“栈逃逸”机制将这种局部变量的空间分配在堆上：  
```go
    func sum(a, b int) *int {
        sum := a+b
        return &sum
    }
```

## 闭包
闭包 = 函数 + 引用环境。也可以说，闭包是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。实际上，这是利用了“栈逃逸”机制。  

一般来说，由 匿名函数引用外部函数的局部变量或者是包全局变量 构成一个闭包。闭包通常用于减少全局变量，避免污染全局空间。  
例如下列函数可以生成一个从 i 开始的自增器，又不污染全局空间。**所以不推荐在闭包中引用全局变量**
```go
func getSequence(i int) func() int {
    return func() int {
        a := i
        i+=1
        return a  
    }
}
increaser := getSequence(0)
a := increaser()
b := increaser()
c := increaser()
// a b c 分别为 0 1 2
```  
当闭包所引用的外部变量是函数的局部变量或是参数时：  
多次调用生成匿名函数的函数，返回的多个闭包所引用的外部变量（例如 i）是多个副本，各自拥有独立的内存地址。但是多次调用一个闭包函数多次，闭包函数内对其引用的外部变量的操作会影响到该闭包所关联的副本。  
另外需要注意的是，同一个函数若是同时返回了多个闭包，这些闭包共享该函数的局部变量。  

当闭包所引用的外部变量是全局变量时： 
每次操作都会影响全局变量。

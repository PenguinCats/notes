# 特性与机制

## 栈逃逸机制

GO 函数中允许返回局部变量的地址。Go编译器使用“栈逃逸”机制将这种局部变量的空间分配在堆上：  

```go
    func sum(a, b int) *int {
        sum := a+b
        return &sum
    }
```

## 闭包

闭包 = 函数 + 引用环境。也可以说，闭包是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。实际上，这是利用了“栈逃逸”机制。  

一般来说，由 匿名函数引用外部函数的局部变量或者是包全局变量 构成一个闭包。闭包通常用于减少全局变量，避免污染全局空间。  
例如下列函数可以生成一个从 i 开始的自增器，又不污染全局空间。**所以不推荐在闭包中引用全局变量**

```go
func getSequence(i int) func() int {
    return func() int {
        a := i
        i+=1
        return a  
    }
}
increaser := getSequence(0)
a := increaser()
b := increaser()
c := increaser()
// a b c 分别为 0 1 2
```

当闭包所引用的外部变量是函数的局部变量或是参数时：  

+ 多次调用生成匿名函数的函数，返回的多个闭包所引用的外部变量（例如 i）是多个副本，各自拥有独立的内存地址。

+ 但是多次调用一个闭包函数多次，闭包函数内对其引用的外部变量的操作会影响到该闭包所关联的副本。  

+ 另外需要注意的是，同一个函数若是同时返回了多个闭包，这些闭包共享该函数的局部变量。  

当闭包所引用的外部变量是全局变量时： 每次操作都会影响全局变量。

**以一种更高度的概括来说**

- **如果外部函数的所有变量可见性都是local的，即生命周期在外部函数结束时也结束的，那么闭包的环境也是封闭的**。

- **反之，那么闭包其实不再封闭，全局可见的变量的修改，也会对闭包内的这个变量造成影响**。例如下面，i 进行修改之后，是会有影响的！但是第二种就不会。
  
  ```go
      for i := 0; i <= 10; i++ {
          go func() {
              fmt.Println(i)
          }()
      }
  
      for i := 0; i <= 10; i++ {
          go func(i int) {
              fmt.Println(i)
          }(i)
      }
  ```

进一步的关于闭包延迟绑定的例子

```go
func foo7(x int) []func() {
    var fs []func()
    values := []int{1, 2, 3, 5}
    for _, val := range values {
        fs = append(fs, func() {
            fmt.Printf("foo7 val = %d\n", x+val)
        })
    }
    return fs
}
// Q4实验：
f7s := foo7(11)
for _, f7 := range f7s {
    f7()
}

foo7 val = 16
foo7 val = 16
foo7 val = 16
foo7 val = 16
```

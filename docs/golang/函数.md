# 函数
## 不定参数
使用 `param ...type` 来声明。

## defer
defer 注册延时调用，在本函数返回前，按照注册的顺序，先注册的后执行。 defer 只能注册方法与函数，不能注册语句，可以使用匿名函数规避此问题。  
defer 可以用于避免资源泄露，例如及时关闭管道避免遗忘，关闭数据库连接等等。  
defer 中避免对有名的返回值操作。

## 底层实现
Go　函数使用的是　caller-save 模式，即由调用者负责保存栈寄存器，在主调函数调用被调函数的头尾会有保存现场和回复现场的操作。
+ 多值返回　　
    函数调用前先为返回值和参数分配空间。先分配返回值空间，再分配参数空间。需要返回多少个参数就提前分配多少空间，所以多值返回的实质就是在栈上开辟多个地址空间分别存放返回值。如果返回值要存在栈上，那么多了一个复制的动作，复制过去而已。
+ 闭包实现　　
    Go 的闭包通过如下结构实现
    ```go
    type Closure struct {
        F uintptr
        env *Type
    }
    ```  
    F是返回的匿名函数指针，env是对外部环境变量的引用集合。检测到闭包之后编译器会生成上述结构的内存空间并存储，将闭包所引用的外部变量复制到闭包对象副本的位置中去（引用函数局部变量或是参数时），之后函数内部对外部环境变量的操作会在这个副本上进行。

## 函数类型
有名函数与匿名函数**的类型**都属于未命名类型，也叫作**函数字面量类型**，而使用 `type` 定义的函数类型叫做函数命名类型。  
例如 `func add(int, int) int{}` 和 `func (int, int) int{}` 分别是有名函数和匿名函数，他们的类型就是函数签名：  函数签名是不包含函数名的“字面量类型”，如 `func (int, int) int`  
而 `函数声明=函数名+函数签名`, 如 `func FuncName (int, int) int` 

## 方法集
一个类型的方法集包括，接受者是值类型 T 的方法集S，接受者为指针类型 *T 的方法集 *S。  
T类型的方法集是 S， *T类型的方法集是 S 和 *S。实际上，使用类型实例调用方法时，编译器会进行自动转换，转换成合适的类型。但是需要注意的是，**类型实例传递给接口的时候，编译器不会进行自动转换**，而是会进行严格的方法集校验。

# HTTP 概览

## HTTP 幂等

> 一口气说出四种幂等性解决方案，面试官露出了姨母笑~ - 不才陈某的文章 - 知乎
> https://zhuanlan.zhihu.com/p/337245010

### 什么是幂等

**幂等**是一个数学与计算机学概念，在数学中某一元运算为幂等时，其作用在任一元素两次后会和其作用一次的结果相同。在计算机中编程中，一个幂等操作的特点是其**任意多次执行所产生的影响均与一次执行的影响相同**。

在`HTTP/1.1`中，对幂等性进行了定义。**它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果**（网络超时等问题除外），即第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。

### 为什么要幂等

在接口调用时一般情况下都能正常返回信息不会重复提交，不过在遇见以下情况时可以就会出现问题，如：

1. **前端重复提交表单**： 在填写一些表格时候，用户填写完成提交，很多时候会因网络波动没有及时对用户做出提交成功响应，致使用户认为没有成功提交，然后一直点提交按钮，这时就会发生重复提交表单请求。  

2. **用户恶意进行刷单**： 例如在实现用户投票这种功能时，如果用户针对一个用户进行重复提交投票，这样会导致接口接收到用户重复提交的投票信息，这样会使投票结果与事实严重不符。  

3. **接口超时重复提交**：很多时候 HTTP 客户端工具都默认开启超时重试的机制，尤其是第三方调用接口时候，为了防止网络波动超时等造成的请求失败，都会添加重试机制，导致一个请求提交多次。  

4. **消息进行重复消费**： 当使用 MQ 消息中间件时候，如果发生消息中间件出现错误未及时提交消费信息，导致发生重复消费。

幂等性是为了简化客户端逻辑处理，能放置重复提交等操作，但却增加了服务端的逻辑复杂性和成本，其主要是：

1. 把并行执行的功能改为串行执行，降低了执行效率。  

2. 增加了额外控制幂等的业务逻辑，复杂化了业务功能

### Restful API 接口幂等性如何

![](https://pic2.zhimg.com/v2-34042aebd49e8b457cceadf1a465d499_b.jpg)

### 怎么实现

#### 防重 Token 令牌

针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用 `Token` 的机制实现防止重复提交。

![preview](https://pic4.zhimg.com/v2-8f2ba8b5c5554f98e1c43bbcc12dc44f_r.jpg)

1. 服务端提供获取 Token 的接口，该 Token 可以是一个序列号，也可以是一个分布式 `ID` 或者 `UUID` 串。  

2. 客户端调用接口获取 Token，这时候服务端会生成一个 Token 串。  

3. 然后将该串存入 Redis 数据库中，以该 Token 作为 Redis 的键（注意设置过期时间）。  

4. 将 Token 返回到客户端，客户端拿到后应存到表单隐藏域中。  

5. 客户端在执行提交表单时，把 Token 存入到 `Headers` 中，执行业务请求带上该 `Headers`。  

6. 服务端接收到请求后从 `Headers` 中拿到 Token，然后根据 Token 到 Redis 中查找该 `key` 是否存在。  

7. 服务端根据 Redis 中是否存该 `key` 进行判断，如果存在就将该 `key` 删除，然后正常执行业务逻辑。如果不存在就抛异常，返回重复提交的错误信息。  

> “ 注意，在并发情况下，执行 Redis 查找数据与删除需要保证原子性，否则很可能在并发下无法保证幂等性。其实现方法可以使用分布式锁或者使用 `Lua` 表达式来注销查询与删除操作。

#### 下游传递唯一序列号

 ![preview](https://pic3.zhimg.com/v2-9305db0e27576832f5ae5043601ed84a_r.jpg)

所谓请求序列号，其实就是每次向服务端请求时候附带一个短时间内唯一不重复的序列号，该序列号可以是一个有序 ID，也可以是一个订单号，一般由下游生成，在调用上游服务端接口时附加该序列号和用于认证的 ID。

当上游服务器收到请求信息后拿取该 **序列号** 和下游 **认证ID** 进行组合，形成用于操作 Redis 的 `Key`，然后到 Redis 中查询是否存在对应的 `Key` 的键值对，根据其结果：

1. **如果存在**，就说明已经对该下游的该序列号的请求进行了业务处理，这时可以直接响应重复请求的错误信息。  

2. **如果不存在**，就以该 `Key` 作为 Redis 的键，以下游关键信息作为存储的值（例如下游商传递的一些业务逻辑信息），将该键值对存储到 Redis 中 ，然后再正常执行对应的业务逻辑即可。

#### 数据库乐观锁

数据库乐观锁方案一般只能适用于执行**更新操作**的过程，我们可以提前在对应的数据表中多添加一个字段，充当当前数据的版本标识。

这样每次对该数据库该表的这条数据执行更新时，都会将该版本标识作为一个条件，值为上次待更新数据中的版本标识的值。

![preview](https://pic2.zhimg.com/v2-969bf20a3e5e1fb508bbec685ae1226d_r.jpg)

这样每次执行更新时候，都要指定要更新的版本号，如下操作就能准确更新 `version=5` 的信息：

```text
UPDATE my_table SET price=price+50,version=version+1 WHERE id=1 AND version=5
```

上面 `WHERE` 后面跟着条件 `id=1 AND version=5` 被执行后，`id=1` 的 `version` 被更新为 `6`，所以如果重复执行该条 SQL 语句将不生效，因为 `id=1 AND version=5` 的数据已经不存在，这样就能保住更新的幂等，多次更新对结果不会产生影响。

## 不保存状态

Http 是不保存状态的协议，即无状态协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。在 HTTP 这个级别，协议对于发送过的请求和响应都不做持久化处理。（之后引入了 cookie, token 等）

## Http 中的方法

1. GET：用于获取资源
2. POST：传输实体主体（虽然 GET 也可以用于传输，但是一般不用）
3. DELETE：删除文件
4. PUT：传输文件。和 POST 的区别在于其一般有幂等性 [https://www.zhihu.com/question/48482736](https://www.zhihu.com/question/48482736)
5. HEAD: 和 GET 一样，但是只获得报文首部，不返回主体部分。一般用于确认 URI 有效性和资源更新的时间日期等等
6. OPTIONS：询问支持的方法
7. TRACE：追踪路径
8. CONNECT：要求和代理服务器通信时建立隧道，和隧道进行 TCP 通信。通信时使用  SSL/TSL 加密。

## 持久连接以节省通信量：

1. 持久连接：只有任意一端没有明确提出断开连接，则保持 TCP 连接状态。减少了 TCP 连接的重复建立和断开带来的开销。必须通信的双方都支持。
2. 管线化：发送请求后不需要等待并收到响应，直接发送下一个请求。如请求一个包含 10 张图片的 HTML Web 界面，不需要传完一张图再传下一张图。

## URI 与 URL

[https://www.zhihu.com/question/21950864/answer/28847598](https://www.zhihu.com/question/21950864/answer/28847598)

URI 在于I(Identifier)是统一资源标示符，可以唯一标识一个资源。

URL在于Locater，一般来说（URL）统一资源定位符，可以提供找到该资源的路径，比如 `http://www.zhihu.com/question/21950864`，但URL又是URI，因为它可以标识一个资源，所以URL又是URI的子集。

举个是个URI但不是URL的例子：`urn:isbn:0-486-27557-4`，这个是一本书的isbn，可以唯一标识这本书，更确切说这个是URN。

总的来说，locators are also identifiers, so every URL is also a URI, but there are URIs

## HTTP 1.0、1.1、2.0、3.0

+ HTTP 1.0
  
  + HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。
  + 由于HTTP 1.0 规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。

+ HTTP 1.1
  
  + HTTP 1.1 支持持久连接（HTTP/1.1 的默认模式使用带流水线的持久连接 KEEP-ALIVE），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。
  + HTTP 1.1 支持请求**管道化**（`pipelining`），允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容（所以还是可能会有队头阻塞，所以这个功能基本不用，现在浏览器厂商通常使用多个 TCP 连接）

+ HTTP 2.0
  
  + 二进制分帧：http1.x 诞生的时候是明文协议，其格式由三部分组成：start line（request line或者status line），header，body。文本解析天然慢。
    
    http2.0的协议解析决定采用二进制格式，实现方便且健壮。length定义了整个frame的开始到结束，type定义frame的类型（一共10种），flags用bit位定义一些重要的参数，stream id用作流控制，剩下的payload就是request的正文了。
    
    <img src="4bc1ad44e91207d56493003bf3805048_1440w.png" alt="img" style="zoom:50%;" />
    
    <img src="05563d500d43202464e1e246e8e69e9a_1440w.png" alt="img" style="zoom:50%;" />
  
  + 多路复用：客户端与服务器之间也只需要一个连接即可，节省了连接建立的开销。这样即使来自很多流的数据包也能够混合在一起通过同样连接传输，再根据不同帧首部的 stream id 标识符重新连接将不同的数据流进行组装。
    
    ![preview](v2-7fc42de1ae19588365a6a767c985986c_r.jpg)
  
  + 服务端推送：在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。
  
  + 首部压缩：HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，不变的就不传了。从而避免了重复传输。
    
    <img src="image-20220227205907367.png" alt="image-20220227205907367" style="zoom: 33%;" />

+ HTTP 3.0
  
  + 为什么要替代 HTTP 2.0？
    
    + HTTP/2 解决了 HTTP 的队头阻塞问题，但是并没有解决TCP队头阻塞问题。
      
      TCP 传输过程中会把数据拆分为一个个**按照顺序**排列的数据包，但是如果其中的某一个数据包没有按照顺序到达，接收端会一直保持连接等待数据包返回，这时候就会阻塞后续请求。这就发生了**TCP队头阻塞**。
      
      在HTTP/2中，TCP 队头阻塞造成的影响会更大，因为 HTTP/2 的多路复用技术使得多个请求其实是基于同一个 TCP 连接的，那如果某一个请求造成了 TCP 队头阻塞，那么多个请求都会受到影响。
    
    + TCP 握手时长。如果 RTT 较长的话，可能一次连接建立过程总耗时可能要达到一秒钟左右。
  
  + 咋办
    
    + Google 自己搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。
      
      + 0RTT，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。
        
        传输层 0RTT 就能建立连接。加密层 0RTT 就能建立加密连接。
      
      + 同 HTTP/2 一样，同一个 QUIC 连接上可以创建多个 stream 来发送多个 HTTP 请求，但是，QUIC 是基于 UDP 的，因此一个连接上的多个 stream 之间没有依赖。比如 stream2 丢了一个 UDP 包，不会影响后面跟着 Stream3 和 Stream4
      
      + TCP 协议头部没有经过任何加密和认证，而 QUIC 有。
      
      + 前向纠错机制，每个数据包除了它本身的内容之外，还包括了部分其它数据包的数据，因此少量的丢包可以通过其它包的冗余数据直接组装而无需重传。

## HTTP 超时可能的原因

1. 请求超时
   
   网络超级烂，发起一个请求之后，很长时间都没有到服务器。TCP 建立的过程甚至在不停的失败和重试。

2. 响应超时
   
   业务逻辑过重，服务器没有及时回复消息。客户端如果 5s 没有收到任何回复，可能会判定为超时。

以上两种情况，底层一般都是抛出一个 TimeoutException 的异常。

有一些是会出错但是不会超时的情况，别记混了！

> 1. 请求一个不存在的 URL，但是这个 URL 的域名是存在的
>    
>    响应 404
> 
> 2. 一个不存在的域名
>    
>    很快得到 DNS_PROBE_FINISHED_NXDOMAIN or NotFoundHostException
# 网络安全

网络安全目标：

+ 机密性
+ 认证：双方互相确认身份
+ 报文完整性：不被篡改

## 加密原理

### 对称密钥密码学：发送方和接收方的密钥相同

$ m=k_{A-B}(K_{A-B}(m)) $

+ 如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的
+ 然而最大的问题就是**这个密钥怎么让传输的双方知晓，同时不被别人知道**。
+ 例子：AES

### 公开密钥密码学：用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。

+ $ m=k_{B}^{+}(K_{B}^{-}(m)) $ or$ m=k_{B}^{-}(K_{B}^{+}(m)) $。从计算带加上来说，从公钥推不出私钥，反之亦然。

+ 例子：RSA

  <img src="image-20220126173501089.png" alt="image-20220126173501089" style="zoom: 50%;" />

### 可信公钥 certification  authority (CA) 

在非对称加密中，如何**确保对方发来的公钥是可靠的**，而不是被中间人篡改成它自己的？利用 CA 机构。

+ E 到 CA 注册自己的公钥，并提供自己的**身份证明**（伪装者不能证明自己真的是这个域名的所有人）
+ CA创建一个证书，捆绑了 实体信息和他的公钥. 该证书是被CA签署的（被CA用自己的私钥加了密的），**证书里包含了 E 的信息，如括域名**
+ 当别人需要或许 E 的公钥，就去拿这个证书，并用 CA 的公钥来认证。若认证通过，就可以解密出 E 的公钥。

#### 怎么证明CA机构的公钥是可信的？

+ CA 机构的公钥是否也可以用数字证书来证明？

  是的，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。

+ 实际上证书之间的认证也可以不止一层，可以 A 信任 B，B 信任 C，以此类推，我们把它叫做**信任链**或**数字证书链**。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。
+ 有时候一些网站访问不了需要安装证书，说明浏览器不认可给这个网站颁发证书的机构，那么你就得手动下载安装该机构的根证书（风险自己承担）

<img src="v2-04cd27f3f46388df2d8d70375c4ecac5_1440w.jpg" alt="img" style="zoom: 67%;" />

## HTTPS 原理

> 彻底搞懂HTTPS的加密原理 - 顾伊凡 YGY的文章 - 知乎 https://zhuanlan.zhihu.com/p/43789231

+ 仅用对称加密可行吗？

  不行。如何协商一个对称密钥很难不被他人知晓。也不可能预先在所有浏览器和服务器存放一对一的密钥。

+ 仅用非对称加密可行吗？

  不好。服务器预先向浏览器发送公钥，浏览器把自己的内容加密后传输，服务器用私钥解密。【但是只有浏览器到服务器的单一方向是安全的】【而且还需要从 CA 获取公钥，直接采用服务器发来的公钥，可能是被中间人篡改成他自己的】

+ 如果改进一下，浏览器也向服务器发一个自己的公钥呢？

  每个浏览器都去 CA 注册一下不太现实，如果不去 CA 注册，服务器也就不能确定浏览器发来的公钥是不是真的是它自己的。

  **更严重的是，非对称加密算法非常耗时，而对称加密快很多。**

  > 加密主要的运算是**位运算**，非对称加密有很多乘法和取模操作。

+ 那怎么办呢最后？采用非对称加密 + 对称加密结合的方式
  + 浏览器获得服务器的公钥 A+（通过 CA 认证的，也称证书）
  + 浏览器随机生成一个用于对称加密的密钥 X，用服务器的公钥 A+ 加密后传给服务器。
  + 服务器用自己的私钥 A- 解密，得到对称密钥 X
  + 之后双方所有数据都通过密钥 X 加密解密

## OAuth 2.0

+ 什么是 OAuth?

  开放授权（OAuth）是一个开放标准，允许用户让**第三方应用**访问该用户在**某一网站上存储的私密的资源**（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。**OAuth 的核心就是向第三方应用颁发令牌。**

  需要注意的是，`OAuth 2.0`是为授权(Authorization)的，不是为了认证(Authentication)。

+ 基本流程

  + 第三方应用请求用户授权。
  + 用户同意授权，并返回一个凭证（code）（实际上也是授权服务器颁发的）
    + 以网页认证为例。当我们向授权服务器**提交应用信息时，通常需要填写一个 redirect_uri**，当我们引导用户**进入授权页面时，也会附带一个redirect_uri **的信息，当授权服务器验证两个URL一致时，会通知浏览器跳转到 redirect_uri，同时，在 redirect_uri 后附加用户凭证（code）的相关信息。如 `http://tianmaying.com/oauth/github/callback?code=9e3efa6cea739f9aaab2&state=XXX`或`com.app.read//callback?code=oMsCeLvIaQm6bTrgtp7`（根据第三方是网站还是 app 还是别的，各不相同）
    + 用户主动行为结束，用户理论上可以不需要再做任何主动的操作。接下来的行为都在第三方应用与授权服务器、资源服务器之间的交互。
  + 第三方应用通过第二步的凭证（code）向授权服务器请求授权
    + 要拿到授权需要如下信息：
      + client_id 标识第三方应用的 id，由授权服务器在**第三方应用提交时颁发给第三方应用**
      + client_secret 第三方应用和授权服务器之间的安全凭证，由授权服务器在**第三方应用提交时颁发给第三方应用**
      + code 第一步中返回的用户凭证 redirect_uri 第一步生成用户凭证后跳转到第二步时的地址
      + state 由第三方应用给出的随机码
    + 上述涉及到client_secret 第三方应用和授权服务器之间的安全凭证，OAuth 要求该请求必须是 POST 请求，同时，还必须是 HTTPS，以此保证获取到的验证凭证（Access Token）的安全性。
  + 授权服务器验证凭证（code）通过后，同意授权，并返回一个资源访问的凭证（Access Token）。
  + 第三方应用通过第四步的凭证（Access Token）向资源服务器请求相关资源。
    + 此时的访问不是通过浏览器进行的，而第三方应用直接发送 HTTP 请求，因此其安全性是可以保证的。
  + 资源服务器验证凭证（Access Token）通过后，将第三方应用请求的资源返回。

  ![image-20220126194225183](image-20220126194225183.png)

+ 问题

  + 为什么在得到授权码（authentication code）之后，还要再访问一次，将授权码换成访问令牌（access token)

    user agent 可能是不安全的（协议不应该假设用户代理的行为是可信赖的，比如通常的浏览器），如果直接给 access token，很有可能被盗取。

    但 authorization_code 可以给，是因为 authorization_code 并不像 access_token 一样敏感。即使 authorization_code 被泄露，攻击者也无法直接拿到access_token，因为拿 authorization_code 去交换 access_token 是需要验证 Client 的真实身份。

    其次，因为 code 是单次消耗，用完一次就作废的。当黑客窃取到一个 code 的时候，这个 code 已经作废了（用户自己用过了），因此 code 不怕被窃取。而 token 通常是长时间有效的。

  + 我截获了 code，然后自己也搞一个 client 去模拟操作，利用截获的 code 和真实的应用去访问怎么办？这不是 oauth 的问题了，第三方应用或许需要一些调整。

    > 首先，code 被截获很难有办法。上层的任何保护手段都防范不了下层的安全漏洞，OAuth2 一个应用层之上的玩意儿，没法考虑下层的安全问题。
    >
    > 其次，client 的 client_secret 需要 client 自己保证，如果第三方 client 不靠谱，那就根本不应该给它提交注册的机会。用户面对这样一个风险应用，也不应该随便授权。就算应用的 client_secret  泄露了，因为 code 是单次消耗，用完一次就作废的，所以也可能还算安全。

## OIDC
> https://www.cnblogs.com/linianhui/p/openid-connect-core.html
> 
> 过于详细！终于搞懂SSO里面的SAML和OIDC讲的啥了 - 敲代码的阿克的文章 - 知乎
> https://zhuanlan.zhihu.com/p/312224113
> 
> https://deepzz.com/post/what-is-oidc-protocol.html

通过 OAuth 实现身份验证。感觉像是在返回 access token 的时候加了一个 ID token。

ID token 是加密过的 User ID 之类的东西，可以供第三方来找自己的用户。也可以往它的 payload 里加入一些用户的信息，这样就不需要拿着 access token 再消耗一次请求的时间去拿用户信息了。

当然你也可以拿着这个 access token 再去资源服务器拿一些用户信息。

> 思考：为啥不把用户信息直接加在 access token 里面呢
> 除了登录，其他认证也需要获取 access token。但是他们不需要用户信息啊。登录和授权还是分离比较好。
# MySQL

## MySQL 的存储引擎

存储引擎是对**底层物理数据**执行实际操作的组件，为 Server 服务层提供各种操作数据的 API。常用的存储引擎有 InnoDB、MyISAM、Memory。

### InnoDB 

> in-no-DB

+ InnoDB 是 MySQL 的默认事务型引擎，支持事务
+ 表是基于聚簇索引建立的。支持表级锁和行级锁，支持外键，适合数据增删改查都频繁的情况。
+ InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 **可重复读** REPEATABLE READ，并通过 MVCC + Next-Key Locking 防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。

> + InnoDB 是 MySQL 默认的事务型存储引擎，只有在需要 InnoDB 不支持的特性时，才考虑使用其它存储引擎。
> + 主索引是**聚簇索引**，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。
> + 内部做了很多优化，包括从磁盘读取数据时采用的**可预测性读**、能够自动在内存中创建哈希索引以加速读操作的**自适应哈希索引**、能够加速插入操作的插入**缓冲区**等。
> + 通过一些机制和工具支持真正的热备份。

### MyISAM

> my-I-sam

+ MyISAM 不支持事务，
+ **崩溃后无法安全恢复**。
+ MyISAM 支持表级锁，不支持行级锁，表不支持外键
+ 该存储引擎存有表的行数，count 运算会更快。适合查询频繁，不适合对于增删改要求高的情况

> + 不支持行级锁，**只能对整张表加锁**，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为**并发插入**（CONCURRENT INSERT）。
> + 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的**键缓冲区**，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。
> + MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等。
> + MyISAM 设计简单，**数据以紧密格式存储**，所以在某些场景下性能很好。

## 索引

### 优缺点

优点：

+ 大大加快数据的检索速度，这也是创建索引的最主要的原因
+ 加速表和表之间的连接
+ 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
+ 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

缺点：

+ 时间方面：当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度
+ 空间方面：索引需要占物理空间

### 一些索引

#### B Tree & B+ Tree

##### 数据结构

B Tree 指的是 Balance Tree，也就是平衡查找树。B 树是一种**多路**搜索树。**所有叶子节点位于同一层**（实际上这些结点不存在，指向这些结点的指针为空）。（非叶节点会有数据指针）

B+ Tree 是基于 B Tree 的改进，首先其内节点只有索引，没有数据指针，其次其所有的叶子节点都用链表相连。数据指针全在叶子节点上。（inndoDB的具体实现细节可能有所不同，看聚簇索引章节）

>  在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key<sub>i</sub> 和 key<sub>i+1</sub>，且不为 null，则该指针指向节点的所有 key 大于等于 key<sub>i</sub> 且小于等于 key<sub>i+1</sub>。

<img src="l6UyF.png" alt="B and B+ tree" style="zoom: 50%;" />

![aedee55f4cc5446a1bebc4c8626587fc.png](aedee55f4cc5446a1bebc4c8626587fc.png)

##### 操作

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。

##### 磁盘原理和比较

一般来说索引非常大，为了减少内存的占用，索引也会被存储在磁盘上。由于磁盘 IO 的耗时远高于内存内的二分查找，评价一个数据结构作为**索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度**。

InnoDB 将其一个节点的大小称为一个页（通常是16KB），注意这和操作系统和的页不是一回事。不过，InnoDB 可以主动调整或者被动期待，自己的这一个页会被映射到 OS 的一页（或多个页）（通常是磁盘块大小的倍数，磁盘块大小通常是4KB，专用于服务器的硬盘可能是16KB）。

InnoDB 将一个**索引的节点的大小设置为一页的大小**，这样从硬盘读入的时候，可以期待内存只需要换一个页（或页的整数倍）就可以，一次就可以完全载入一个节点。

> 一次磁盘 IO 读一页而不是一个字节是因为 磁盘的预读特性。为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入主存，这个长度就是一个磁盘块。

> https://dba.stackexchange.com/questions/224969/what-is-the-relation-between-mysql-pages-and-operating-system-pages
>
> https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-diskio.html
>
> https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_page_size

###### B & B+

+ B+ 树改进了 B 树, 让内节点只作索引使用，去掉了其中指向 data record 的指针，**使得每个结点中能够存放更多的 key**，因此能有更大的出度。这样就意味着树的**层高能进一步被压缩**, 使得检索的时间更短，而且减少了读索引的磁盘操作。
+ 由于底部的叶子结点是链表形式, 因此也可以实现更方便的**顺序遍历**（**范围查询**的时候很有用吧，找到头尾，中间直接一个串一个找过去）
+ B+ 树一定要查到叶子节点，所以查询效率稳定

> 什么MongoDB用B树而不是B+树？
>
> MongoDB 作为面向文档的数据库，与数据之间的关系相比，它更看重以文档为中心的组织方式，所以选择了查询**单个文档性能较好的** **B** **树**（因为不用查到叶子节点了吧，可能中间就返回了吧），这个选择对遍历数据的查询也可以保证可以接受的时延；

###### 与红黑树的比较

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。

平衡树的树高 O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。如果每个节点存储一个关键词，数据量大时，红黑树的深度很深，每次读取时消耗大量 IO。B+ 树相对于红黑树有更低的树高，磁盘 IO 读取索引中间节点的次数更少，所以 B+ 树更适合磁盘数据的读取。**值得注意的是，你不能指望红黑树父子索引节点在一个 OS 页上或在连续磁盘块上。**

###### 与 hash 的比较

> https://www.cnblogs.com/igoodful/p/9361500.html

哈希索引能以 O(1) 时间进行查找，但是：

- 只支持精确查找，**无法用于范围查找，也不能高性能的排序和分组。**

  例如WHERE price > 100。由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，**因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和 Hash 运算前完全一样。（那么这些 Hash 记录可能在不同的盘块上，要一个一个读进来）**

  （甚至后面加间隙锁等等都不好操作）

- 数据量大了之后，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。**查询性能受 hash 冲突率影响，性能不稳定**。【碰撞之后要遍历了啊！遍历！】

- 没法应对联合索引，因为 hash 拆开来算没意义

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

#### 全文索引

全文索引**使用倒排索引实现**，它记录着**关键词到其所在文档的映射**。

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

**InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。**

#### 空间数据索引

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。

#### 联合索引和最左匹配原则

使用**多个字段**同时建立一个索引（比如 B+ 树索引）叫做联合索引。在联合索引中，如果想要命中索引，**需要按照建立索引时的字段顺序挨个使用**，否则无法命中索引。

联合索引底层还是一颗 B+ 树，只不过联合索引的健值数量不是一个，而是多个。但是构建一颗 **B+ 树只能根据一个值来构建**，因此数据库依据联合索引**最左的字段来构建B+树**。但是**前一个键等值的情况下，按后一个键值的顺序关系建索引**。

<img src="v2-9dab07a4adc00c794f80e91bc0289e36_r.jpg" alt="preview" style="zoom: 67%;" />

###### 最左匹配原则

最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询 (>、<、between、like) 就会停止匹配。

> 例如：如果建立 (a, b) 顺序的索引，我们的条件只有 b=xxx，是匹配不到 (a, b) 索引的
>
> 但是如果查询条件是 a = 1 and b = 2 或者 b=2 and a=1就可以，因为优化器会自动调整 a, b 的顺序，并不需要严格按照索引的顺序来
>
> 再比如查询 a = 1 and b = 2 and c > 3 and d = 4 如果建立(*a, b, c, d*)顺序的索引，d 是用不到索引的，因为 c 字段是一个范围查询，它之后的字段会停止匹配。

#### 聚簇索引

**聚簇索引：**表中数据存储的物理顺序与索引值的顺序一致

+ 一个基本表最多只能有一个聚簇索引
+ 聚簇索引对于那些**经常要搜索范围值的列、需要排序的列、需要分组的列**特别有效。当索引值唯一时，使用聚簇索引查找特定的行也很有效率。例如，使用唯一雇员 ID 列 emp_id 查找特定雇员的最快速的方法，是在 emp_id 列上创建聚簇索引或 PRIMARY KEY 约束。
+ 更新聚簇索引列上的数据时，往往导致表中记录的物理顺序的变更，代价较大，因此对于经常更新的列不宜建立聚集索引。

**非聚簇索引：**表中数据的物理顺序与索引值的顺序不一致的索引组织

+ 聚簇索引和非聚簇索引都采用了 B+ 树的结构，但**聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，只不过其包含一个指向对应数据块的指针。**
+ 一个基本表可以有多个非聚集索引（对每个表最多可以建立 249个非聚集索）。
+ 非聚集索引需要大量的硬盘空间和内存。另外，虽然非聚集索引可以提高从表中取数据的速度，它也会**降低向表中插入和更新数据的速度**（因此频繁更改的表不适宜）。每当改变了一个建立了非聚集索引的表中的数据时，必须同时更新索引。

**innoDB 中：** 聚簇索引的叶子节点 data 域记录着完整的数据记录，非聚簇索引的叶子节点的 data 域记录着主键的值，因此在使用非聚簇索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。【而不是直接从非聚簇索引的叶子节点指针指向数据】

### 索引失效

以后再补充

### 索引优化【不太重要的样子，以后再说】

#### 1. 独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

例如下面的查询不能使用 actor_id 列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

#### 2. 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

```sql
SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

#### 3. 索引列的顺序

让选择性最强的索引列放在前面。

索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。**选择性越高，每个记录的区分度越高，查询效率也越高。**

例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

```sql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
```

```html
   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
```

#### 4. 前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

前缀长度的选取需要根据索引选择性来确定。

#### 5. 覆盖索引

**索引包含所有需要查询的字段的值**。例如我查询：主键范围在 100-150 之间的那些记录的主键是什么。

具有以下优点：

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
- **对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引**。

# 面试题没想出来的题目

1. bin log 有几种模式？里面存的是什么？
   
   + bin log 主要用于主从复制和辅助数据恢复。
   + bin log 的刷盘时机是：
     + 0：不去强制要求，由系统自行判断何时写入磁盘
     + 1：每次 commit 的时候都要将 binlog 写入磁盘【现在的默认设置】
     + N：每N个事务，才会将 binlog 写入磁盘
   + bin log 有三种模式：
     + Statement：包含产生数据变化的 **SQL 语句**
       + 【优】产生的日志文件少， IO 次数少
       + 【劣】在一些**不安全的语句上**，主从复制做不到数据一致，比如
         + 含有系统函数的语句，可能会在副本上返回不同的值，如 `RAND(), USER(),UUID(), SYSDATE() ....`（尤其是涉及到日期，从机上和主机上操作很容易出现不一致）
         + ...
       + 慢 SQL 会在副本中再执行一次
     + Row：**描述单个行的变化**【Default】
       + 【优】这是最安全的复制形式
       + 【优】不会出现某些特定情况下的存储过程，或 function，以及 trigger 的调用和触发无法被正确复制的问题
       + 【优】在 `INSERT/UPDATE/DELETE` 语句中，副本相对主行锁范围更小
       + 【劣】`RBL` 日志文件更大，比如一条update语句，如修改多条记录，则每一条修改都会有记录
     + Mixed：上述两者结合使用
       + 一般的语句修改使用 statment 格式保存 binlog
       + 一些函数，statement 等若是无法满足主从复制的需求，则采用 row 格式保存 binlog
         2+ 什么是数据库引擎？
   
   > 如何形象生动的描述数据库引擎这个概念？ - 机智飞的回答 - 知乎
   > https://www.zhihu.com/question/40891412/answer/88725935
   > 
   > 数据库存储引擎的「引擎」是什么概念？ - 朱嫑膘的回答 - 知乎
   > https://www.zhihu.com/question/37029067/answer/1152069891
   
   MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。
   
   通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。
   
   **存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。**
   
   + 存储引擎首先要把由操作系统提供的方法进行改造，使其适配 DBMS的需求或传统。比如：有的要指定每次从磁盘上至少取多少数据作为一个块。
   
   + 存储引擎规定了各种逻辑存储单元的格式。比如记录的结构（记录头格式），各种页（记录页，系统信息页）的结构（页头，页描述符）。
   
   + 存储引擎提供了索引结构。
     
     一个数据库支不支持B＋树索引、哈希索引是由存储引擎决定的。
   
   + 存储引擎还要指定基本的数据二进制表达。比如这个存储引擎如何制定众多整数分别要占用多少字节， 变长数据是存长度还是存标记。
   
   + 存储引擎还要规范各种物理存储单元在磁盘上的一维布局。数据在磁盘上的物理地址是一维线性的，因此存储引擎必须提供对其进行整理，提供具有各种独特语义的存储单元，如页，区，段，还要提供数据结构对他们进行分发和访问。
   
   + 存储引擎的大部分其他功能就是 optional 了，比如是否支持事务，日志，DML编译，优化等等。

2+ limit & offset 大和小的性能区别

> MySQL性能优化有哪些办法？ - 子岸的回答 - 知乎
> https://www.zhihu.com/question/362895379/answer/2622020537
> 
> https://zhuanlan.zhihu.com/p/419597601

1. 如果直接用 limit & offset
   
   会很慢，**需要做全表扫描**，他要一行一行的扫过去
   
   ```sql
   select * from a where is_deleted='N' limit 100000, 5;
   ```

2. **覆盖索引优化**
   
   ```sql
   select a.* from table_1 a,(select id from table_1 b where val >= 10 limit 100000,20) where a.id = b.id
   ```
   
   在 val 上有索引的情况下，先通过 limit 得到需要数据的主键 ID，然后再通过原表和索引字段关联获得需要数据。

3. 如果没有 where 这样的条件的话
   
   每次记一下上次最后一个 ID 是什么，这样就可以借助主键索引直接跳过大量无关紧要的东西
   
   ```sql
   select a.* from a where id >= XXX limit 10;
   ```

# 网上看到的一些不错的题目

1. 拆入海量数据怎么办？
   
   + INSERT 批量插入，而不是一次插入一条。
     + 网络传输数据量少
     + 一次只涉及一个事务
     + binlog 写的东西少
   + 先删除索引，等全部插入完了再重建索引。
   + 禁用唯一性检查，全部插入完之后再排查。

2. 慢查询处理？
   
   慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阀值的语句，具体指运行时间超过long_query_time 值的 SQL，则会被记录到慢查询日志中。
   
   + 可以用 EXPLAIN 来分析原因。常见的原因是，索引没起作用。可以从索引失效的角度去解决。
   
   + 优化步骤走一走
   
   + 查一些分页之类的操作，尽可能的使用索引覆盖扫描，可以先只 SELECT 主键，然后再用主键查出其他列。